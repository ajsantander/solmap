const SourcemapUtil = {

  // See: https://github.com/ethereum/solidity/blob/develop/docs/miscellaneous.rst#source-mappings
  // for documentation on Solidity's sourcemaps.
  
  /*
   * Given a string generated by DisassemblerUtil,
   * find the corresponding instruction at a given character offset.
   * Each line in the disassembler output should start with an instruction number, followed
   * by a space.
   * */
  findInstructionNum(content, pos) {

    // Sweep back from pos looking for returns.
    // Remember where spaces are found.
    // When a return is found, read the instruction number.
    let prevChar = "";
    let spaceIdx = 1;
    let char = content.charAt(pos);
    while(pos !== 0 && prevChar !== "\n") {
      char = content.charAt(pos);
      if(char === " ") spaceIdx = pos;
      pos--;
      prevChar = content.charAt(pos - 1);
    }
    return parseInt(content.substring(pos, spaceIdx), 10);
  },

  findPreviousReturn(content, pos) {
    if(pos === 0) return 0;
  
    // Sweep back from pos looking for returns.
    // When a return is found, return the position.
    pos--;
    let char = content.charAt(pos);
    while(pos > 0 && char !== "\n") {
      pos--;
      char = content.charAt(pos);
    }
    return parseInt(pos);
  },

  findNextReturn(content, pos) {
  
    // Sweep forward from pos looking for returns.
    // When a return is found, return the position.
    let char = content.charAt(pos);
    while(pos !== content.length - 1 && char !== "\n") {
      pos++;
      char = content.charAt(pos);
    }
    return parseInt(pos + 1);
  },

  /*
   * Given a string generated by DisassemblerUtil,
   * translate a character range to an instruction range.
   * */
  disassemblerRangeToInstructionRange(content, range) {
    const start = SourcemapUtil.findInstructionNum(content, range.start);
    const end = SourcemapUtil.findInstructionNum(content, range.end - 1);
    return { start, end }
  },

  /*
   * Given a string generated by DisassemblerUtil,
   * expands the character range to match whole lines.
   * */
  expandDisassemblerRange(content, range) {
    return {
      start: SourcemapUtil.findPreviousReturn(content, range.start),
      end: SourcemapUtil.findNextReturn(content, range.end)
    }
  },

  /*
   * Given a string generated by DisassemblerUtil,
   * translate a character range to a sourcemap range using the 
   * corresponding sourcemap generated by the Solidity compiler.
   * */
  disassemblerRangeToSourceRange(content, range, srcmap) {

    // Translate disassembler text range to instruction range.
    const instructionRange = SourcemapUtil.disassemblerRangeToInstructionRange(content, range);

    // Decompress srcmap.
    srcmap = SourcemapUtil.decompressSourcemap(srcmap);
    
    // Translate instruction range to src range.
    const instructionStart_sourceStart = parseInt(srcmap[instructionRange.start][0], 10);
    const instructionStart_sourceEnd = parseInt(instructionStart_sourceStart, 10) + parseInt(srcmap[instructionRange.start][1], 10);
    const instructionEnd_sourceStart = parseInt(srcmap[instructionRange.end][0], 10);
    const instructionEnd_sourceEnd = parseInt(instructionEnd_sourceStart, 10) + parseInt(srcmap[instructionRange.end][1], 10);

    // Merge ranges.
    const start = Math.min(instructionStart_sourceStart, instructionStart_sourceEnd);
    const end = Math.max(instructionStart_sourceEnd, instructionEnd_sourceEnd);

    return {
      start,
      end
    }
  },

  // Receives a compressed source map in string format in the form:
  // "s:l:f:j;s:l:f:j;..."
  // and returns
  // a decompressed source map in a nested array format of the form:
  // [ ['s', 'l', 'f', 'j'], ['s', 'l', 'f', 'j'], ... ]
  decompressSourcemap(srcmap) {
    
    // Compression:
    // 1:2:1;1:9:1;2:1:2;2:1:2;2:1:2
    // 1:2:1; :9  ;2:1:2;     ;
    // 1:2:1;:9;2:1:2;;
    
    // Sweep the compressed mappings and
    // build a new decompressed one.
    const mappings = srcmap.split(';');
    let lastMapping = mappings[0].split(':'); // 1st mapping assumed to always be decompressed
    const newMappings = [lastMapping];
    for(let i = 1; i < mappings.length; i++) {

      // Read next mapping.
      const mapping = mappings[i].split(':');
    
      // Push new mapping, completing entries if necessary.
      const newMapping = [];
      while(newMapping.length < 4) {
        const idx = newMapping.length;
        if(mapping.length <= idx) mapping.push('');
        newMapping[idx] = mapping[idx] === '' ? lastMapping[idx] : mapping[idx];
      }
      newMappings.push(newMapping);
      lastMapping = newMapping;
    }

    return newMappings;
  }
}

module.exports = SourcemapUtil;
